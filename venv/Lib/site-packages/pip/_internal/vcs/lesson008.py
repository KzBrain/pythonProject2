#Task1
class Data:
    def __init__(self,day_month_year):
        self.day_month_year = str(day_month_year)
    @classmethod
    def total(cls,day_month_year):
        data = []

        for i in day_month_year.split() :
            if i != '-' :
                data.append(i)
        return int(data[0]) ,int(data[1]) ,int(data[2])
    @staticmethod
    def whole(day,month,year):
        if 1 <= day <= 31 :
            return 'right'
        else:
            return f'not correct day'
        if 1 <= month <= 12:
            return f'right'
        else:
            return f'not correct month'
        if 0 <= year <= 2022 :
            return f'right'
        else:
            return f'not right year'

    def __str__(self):
        return f'Текущая дата {Data.total(self.day_month_year)}'
day = Data('1 - 12 -2022')
print(day)


#Task2
class ZeroDivision(Exception) :
    def __init__(self,value):
        self.value = value
try:
    number1 = int(input('digit1:'))
    number2 = int(input('digit2:'))
    answer = number1/number2
    if number2 <= 0 :
         raise ZeroDivision('not zero')
    else:
        print(answer)
except ZeroDivisionError :
    print('impossible')

#Task 3
class Onlydigit(Exception):
    def __init__(self,digit):
        self.digit = digit
try:
    syfer = 0
    while True :
        syfer == int(input())
        if syfer == str:
            raise Onlydigit('only digit')


except ValueError:
    print('not a number')

except Onlydigit :
      print(' digit')
else:
    print(syfer)


class Storage:
    def __init__(self,year,make,model):
        self.year = year
        self.make = make
        self.model = model
    def __str__(self):
        return f'where was made:{self.make},when was make:{self.year},the model:{self.model}'
class Printer(Storage):
    def __init__(self,year,make,model):
        super().__init__(year,make,model)
    def print(self):
        return f'printing'
class Skan(Storage):
    def __init__(self,year,make,model):
        super().__init__(year,make,model)
    def skan(self):
        return f'skanning'
class Copy(Storage):
    def __init__(self,year,make,model):
        super().__init__(year,make,model)
    def copy(self):
        return f'copying'
p = Printer(1998,'China','Kia')
print(p)

#Task 5,6
class StoreMashines:

    def __init__(self, name, price, quantity, number_of_lists, *args):
        self.name = name
        self.price = price
        self.quantity = quantity
        self.numb = number_of_lists
        self.my_store_full = []
        self.my_store = []
        self.my_unit = {'Модель устройства': self.name, 'Цена за ед': self.price, 'Количество': self.quantity}

    def __str__(self):
        return f'{self.name} цена {self.price} количество {self.quantity}'

    # @classmethod
    # @staticmethod
    def reception(self):
        # print(f'Для выхода - Q, продолжение - Enter')
        # while True:
        try:
            unit = input(f'Введите наименование ')
            unit_p = int(input(f'Введите цену за ед '))
            unit_q = int(input(f'Введите количество '))
            unique = {'Модель устройства': unit, 'Цена за ед': unit_p, 'Количество': unit_q}
            self.my_unit.update(unique)
            self.my_store.append(self.my_unit)
            print(f'Текущий список -\n {self.my_store}')
        except:
            return f'Ошибка ввода данных'

        print(f'Для выхода - Q, продолжение - Enter')
        q = input(f'---> ')
        if q == 'Q' or q == 'q':
            self.my_store_full.append(self.my_store)
            print(f'Весь склад -\n {self.my_store_full}')
            return f'Выход'
        else:
            return StoreMashines.reception(self)


class Printer(StoreMashines):
    def to_print(self):
        return f'to print smth {self.numb} times'


class Scanner(StoreMashines):
    def to_scan(self):
        return f'to scan smth {self.numb} times'


class Copier(StoreMashines):
    def to_copier(self):
        return f'to copier smth  {self.numb} times'


unit_1 = Printer('hp', 2000, 5, 10)
unit_2 = Scanner('Canon', 1200, 5, 10)
unit_3 = Copier('Xerox', 1500, 1, 15)
print(unit_1.reception())
print(unit_2.reception())
print(unit_3.reception())
print(unit_1.to_print())
print(unit_3.to_copier())


#Task 7
class ComplexNumbers:
    def __init__(self,a,b):
        self.a = a
        self.b = b
    def __add__(self, other):
        print('+')
        return f'z = {self.a + other.a} + {self.b + other.b}'
    def __mul__(self, other):
        print('*')
        return f'{self.a * other.a - (self.b * other.b)} + {self.b * other.a}'
z1 =ComplexNumbers(1,5)
z2 = ComplexNumbers(2,7)
print(z1)
print(z1 + z2)



















